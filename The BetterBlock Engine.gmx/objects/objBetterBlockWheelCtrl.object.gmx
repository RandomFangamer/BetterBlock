<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprBetterBlockYIChain</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>platforms = 4; //number of platforms
platform[0] = -1;
pushSFX = noone;
dist = 80; //distance from ctrl to platforms
angle = 0; //angle offset
chains = 4; //number of chains to draw from ctrl to the platform (does not include the center chain)

horizontal = true; //draw horizontal path and move horizontally
vertical = true;  //draw vertical path and move vertically

//rotation
playerOn = false;
rotate = true; //can be used to stop the wheel from rotating
rotMult = 0.1; //multiplier to the equation (1 - abs(other.y+8 - y)/dist); maximum degree increase per frame
rotSpd = 0; //rotational speed
rotCap = 4.5; //max speed
frict = 0.032; //subtract from rotation speed when player leaves

//movement values
move = true; //if false, the wheel will not move but will still rotate &amp; draw a path; can be used to stop the wheel from moving
spdMult = 0.15; //multiplier (rotSpd * spdMult = spd)
spd = 0; //speed
spdCap = 4.5; //max speed; if negative, its speed will not be capped

//min x value must be less than max x value
minX = x - 80; //left end of the track
maxX = x + 80; //right end of the track

//if the wheel only moves vertically, leftY should be where you want the wheel to start, and rightY should be the end.
//if leftY is less than rightY, rotating the wheel clockwise will move it down. Otherwise, rotating it clockwise will move it up.
leftY = y - 80; //left end of the track
rightY = y + 80; //right end of the track

//positioning
trackPos = 0; //Percentage representing progress from min to max values on track. 0 = leftmost; 1 = rightmost
trackSize = 0; //distance from min to max values

image_speed = 0;
alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Calculate track position (based off of x value unless moving only vertically)
if (horizontal || vertical){ //moving in some way
    if (horizontal){
        x = clamp(x, minX, maxX);
        if (minX == maxX) horizontal = false; //divide by 0
        else{
            trackPos = (x - minX) / (maxX - minX);
        }
    }
    if (vertical){
        y = clamp(y, min(leftY, rightY), max(leftY, rightY));
        if (!horizontal){ //only vertical
            if (leftY == rightY) vertical = false; //divide by 0
            else trackPos = (y - leftY) / (rightY - leftY); //works with the lerp function in the Step Event regardless of which value is larger
        }
    }
    if (horizontal &amp;&amp; vertical){
        trackSize = point_distance(minX, leftY, maxX, rightY); //if leftY &gt; rightY, this will still work
    }else if (horizontal){
        trackSize = maxX - minX;
    }else if (vertical){
        trackSize = abs(rightY - leftY);
    }
}

//Create platforms
for(i=platforms;i&gt;0;i--){
    with instance_create(x,y,objBetterBlockWheelPlatform){
        x += lengthdir_x(other.dist,other.angle + other.i*(360/other.platforms)) - 16;
        y += lengthdir_y(other.dist,other.angle + other.i*(360/other.platforms)) - 8;
        other.platform[other.i] = id;
        ctrl = other.id
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i=1;i&lt;=platforms;i++){
    with (platform[i]){
        if (place_meeting(xprevious,yprevious-global.grav,objPlayer))
            other.playerOn = true;
    }
}

if (rotate &amp;&amp; rotSpd != 0){
    //Sound
    if (!audio_is_playing(pushSFX)){
        pushSFX = audio_play_sound(sndBetterBlockWheel, 0, 0); //
    }
    
    //slow down when player is off
    if ((!playerOn &amp;&amp; abs(rotSpd) &lt;= frict) || (playerOn &amp;&amp; abs(rotSpd) &lt;= frict/2))
        rotSpd = 0; //will overshoot 0
    else{
        if (!playerOn)
            rotSpd -= sign(rotSpd)*frict;
    }
    
    //cap the value
    if (rotCap &gt;= 0 &amp;&amp; abs(rotSpd) &gt;= rotCap)
        rotSpd = sign(rotSpd)*rotCap;
    
    //increase angle
    angle += rotSpd;
    
    //audio
    audio_sound_gain(pushSFX, clamp(abs((5*rotSpd)/(3*rotCap)), 0, 1), 0); //1 at max Spd, almost 0 when near 0 Spd
}else audio_stop_sound(pushSFX);

//movement
if (move &amp;&amp; trackSize != 0){
    spd = -rotSpd * spdMult;
    if (spdCap &gt;= 0 &amp;&amp; abs(spd) &gt; spdCap) spd = spdCap*sign(spd);
    trackPos += spd/trackSize;
    trackPos = clamp(trackPos, 0, 1);
    if (horizontal) x = lerp(minX, maxX, trackPos);
    if (vertical) y = lerp(leftY, rightY, trackPos);
}

for(i=1;i&lt;=platforms;i++){
    with (platform[i]){
        x = other.x + lengthdir_x(other.dist, other.angle + other.i*(360/other.platforms)) - 16;
        y = other.y + lengthdir_y(other.dist, other.angle + other.i*(360/other.platforms)) - 8;
    }
}

playerOn = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>audio_stop_sound(pushSFX);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw path
if (move &amp;&amp; (horizontal || vertical)){
    //get points to draw path
    if (horizontal){
        x1 = minX;
        x2 = maxX;
    }else{
        x1 = x;
        x2 = x;
    }
    if (vertical){
        y1 = leftY;
        y2 = rightY;
    }else{
        y1 = y;
        y2 = y;
    }
    //draw the path
    draw_set_color(c_ltgray);
    draw_line_width(x1, y1, x2, y2, 3);
    draw_set_color(c_white);
}
draw_self();
//Draw chains to platforms
for(i=0;i&lt;platforms;i++){
    for(j=1;j&lt;=chains;j++)
        draw_sprite(sprBetterBlockYIChain, 0, x+lengthdir_x(j*(dist/(chains)),angle + i*(360/platforms)), y+lengthdir_y(j*(dist/(chains)),angle + i*(360/platforms)));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
